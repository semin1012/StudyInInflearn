#include <iostream>
using namespace std;

// 1. NULL 크래시
// 프로그램이 뻗었다 하면 95 퍼센트 NULL 크래시다.

// 2. 정수 오버플로우(언더플로우) - (0.001% 발생)

// 3. 메모리 릭 - (0.1% 발생)

// 4. 메모리 오염 
// - 캐스팅 : 포인터를 따라 갔을 때 무엇의 자료형일 것이다라는 주장이 다를 수 있다. << 찾기 어렵다.
// - 버퍼 오버플로우 : 범위를 벗어나서 참조하는 경우. << 찾기 괜찮다.
// - Use-Afet-Free : 참조하고 있었던 값을 free 해서 없앴는데도 계속 참조할 때, 그 자리에 중요한 게 재배치되었다면 터질 수 있다. << free 자리를 바라만 보고 있는 건 괜찮은데, 사용하는 순간 터짐. 뒤늦게 터져서 곤란하다.

int main()
{
	// 정수 오버플로우(언더플로우)
	short hp = 30000;
	
	while (true)
	{
		hp += 1000; // heal을 주는 상황
		// short의 값을 넘어가면 음수로 이상하게 표현되어 갑자기 죽게 될 수 있다. 오버플로우.
		// 크래시가 나지는 않지만 엉뚱하게 동작할 수 있다. 
		// 정수의 범위 체크 중요하다.
	}

	// 메모리 릭
	// 할당, 해제를 제대로 안 하면 문제가 생긴다. 누수가 되어서 계속 갉아먹는다는 뜻. 메모리 사용량이 계속 올라간다.
	// 현업에서는 어떻게 해결하는가?
	// 서버가 빵빵하면 몇 시간 후에 뻗을 것인지 시간을 연락받는다. 그럼 그동안 메모리 동적으로 할당한 부분만 확인하면 된다.
	// 메모리 릭은 금방 찾을 수 있어서 감사하다.

	// 버퍼 오버플로우
	int arr[100];
	// arr[101]; << 오버플로우다.
}
 